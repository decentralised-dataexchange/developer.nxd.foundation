---
id: service-create-individual-consent-record-and-signature
title: "Create consent record and signature"
description: "This endpoint is used to create a consent record and signature object. This returns the same objects with the PK defined."
sidebar_label: "Create consent record and signature"
hide_title: true
hide_table_of_contents: true
api: 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
sidebar_class_name: "post api-method"
info_path: docs/disp-api/disp-api-documentation
custom_edit_url: null
---

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";
import Translate from "@docusaurus/Translate";

<Heading
  as={"h1"}
  className={"openapi__heading"}
  children={"Create consent record and signature"}
>
</Heading>

<MethodEndpoint
  method={"post"}
  path={"/service/individual/record/consent-record"}
  context={"endpoint"}
>
  
</MethodEndpoint>



This endpoint is used to create a consent record and signature object. This returns the same objects with the PK defined.

<Heading
  id={"request"}
  as={"h2"}
  className={"openapi-tabs__heading"}
>
  <Translate id="theme.openapi.request.title">Request</Translate>
</Heading>

<ParamsDetails
  parameters={[{"in":"header","name":"X-ConsentBB-IndividualId","required":true,"schema":{"type":"string"},"description":"Individual ID"}]}
>
  
</ParamsDetails>

<RequestSchema
  title={"Body"}
  body={{"content":{"application/json":{"schema":{"properties":{"consentRecord":{"type":"object","title":"ConsentRecord","description":"A consent record expresses consent (as defined in this building block's specification) to a single DataAgreement. There must be a UNIQUE constraint on (data agreement revision, individual)","x-not-in-database":false,"required":["id","agreementRevisionHash","state"],"properties":{"id":{"type":"string","format":"","example":"","description":"Objects may be passed back by some API endpoints without an ID (PK), denoting that they are a \"draft\", i.e. a ConsentRecord that is not yet stored in the database and only exist in transit. Draft ConsentRecords do not have a Revision, but if paired up with a Signature, a valid Revision should be generated."},"dataAgreementId":{"type":"string","x-fk-model":"DataAgreement","description":"The DataAgreement to which consent has been given"},"dataAgreementRevisionId":{"type":"string","x-fk-model":"Revision","description":"The Revision of the data agreement which consent has been given to"},"dataAgreementRevisionHash":{"type":"string","format":"","example":"","description":"Copy of the revision hash. The hash is the included in the signature and ensures against tampering with the original agreement."},"individualId":{"type":"string","x-fk-model":"Individual","description":"The Individual who has signed this consent record"},"optIn":{"type":"boolean","format":"","example":"","description":"True: The individual has positively opted in. False: The individual has explicitly said no (or withdrawn a previous consent)."},"state":{"type":"string","format":"","example":"","description":"The state field is used to record state changes after-the-fact. It is maintained by the Consent BB itself. Valid states: unsigned/pending more signatures/signed","enum":["unsigned","signed"]},"signatureId":{"type":"string","x-fk-model":"Signature","description":"A signature that hashes all the values of the consent record and has signed it with the key of the Invidiual, making it verifiable and tamper-proof. TBD: Relation to a Signature schema?"},"sectorPreferences":{"type":"array","items":{"type":"object","description":"specifies the preferred sector details","x-not-in-database":false,"required":["sector","location"],"properties":{"sector":{"type":"string","format":"","example":"","description":"Name of the sector"},"optIn":{"type":"boolean","description":"Defines sector is opted in or not"},"isLastUpdated":{"type":"boolean","description":"Defines consent record for this sector is last updated"}}}}}},"signature":{"type":"object","title":"Signature","description":"A generic signature contains a cryptographic hash of some value,  together with a signature created by some private key in another system.  Required signing methods: Revision object or another Signature object.\n","x-not-in-database":false,"required":["payload","signature","verificationMethod","verificationPayload","verificationPayloadHash","verificationSignedBy","timestamp"],"properties":{"id":{"type":"string","format":"","example":"","description":"Objects may be passed back by some API endpoints without an id (PK), denoting that they are a \"draft\", i.e. a Signature that is not yet stored in the database and only exists in transit."},"payload":{"type":"string","format":"","example":"","description":"The final payload that is signed, constructed as a JSON serialisation of fields {verificationPayload: ..., verificationPayloadHash: ..., verificationMethod: ..., verificationArtifact: ..., verificationSignedBy: ..., verificationJwsHeader, timestamp: ..., signedWithoutObjectReference: ..., objectType: ..., objectReference: ...}. Serialised as a JSON dict. If the signature is generated before anything is stored in the database (and has a PK), then the objectReference should be omitted from the payload but filled in afterwards."},"signature":{"type":"string","format":"","example":"","description":"Signature of payload hash, the format of the signature should be specified by either verificationMethod or verificationJwsHeader"},"verificationMethod":{"type":"string","format":"","example":"","description":"A well-known string denoting which method is used. Valid values: TBD. This might be expanded with supported verification methods. There may be a minimal set of supported methods necessary."},"verificationPayload":{"type":"string","format":"","example":"","description":"Internally generated serialised version of the data referenced by objectType and objectReference - by extracting and serialising their data as JSON"},"verificationPayloadHash":{"type":"string","format":"","example":"","description":"Internally generated cryptographic hash of the value to be signed, i.e. the value of verificationPayload"},"verificationArtifact":{"type":"string","format":"","example":"","description":"A verification artifact in the form of a scanned object, image, signature etc"},"verificationSignedBy":{"type":"string","format":"","example":"","description":"Because an identifier's information may change over time, there is a need to store that information at the time of signing. In the case of a cryptographic signature, this field should contain some identifier for looking up or verifying the public key of the signing party. In the case of a non-cryptographic signature, this field could contain a natural individual's names, personal number, email addresses - store a snapshot that binds to the signature at the time of signing. In the case of a cryptographic signature, this may be the fingerprint of the individual's public key or in some cases, a token from the user's ID session."},"verificationSignedAs":{"type":"string","format":"","example":"","description":"DRAFT FIELD: Specifies the relationship between the authorising signature and the invidual which the payload concerns. This is relevant for Consent Records. Possible values: \"individual\" / \"delegate\"."},"verificationJwsHeader":{"type":"string","format":"","example":"","description":"Alternative to the verificationMethod, verificationHash and verificationSignature, give a JWS serialised object (RFC7515)"},"timestamp":{"type":"string","format":"","example":"","description":"Timestamp of signature, currently this field isn't part of the payload so it's not tamper-proof"},"signedWithoutObjectReference":{"type":"boolean","format":"","example":"","description":"Indicates that objectReference was left blank in the serialised version that was signed"},"objectType":{"type":"string","format":"","example":"","description":"Name of the schema model that objectReference points to. Values: \"signature\" or \"revision\"","enum":["revision","signature"]},"objectReference":{"type":"string","format":"","example":"","description":"A symmetric relation / back reference to the objectType that was signed. We are currently just modelling signing another signature (a chain) or signing a Revision (which can be a revision of a consent record, an agreement, policy etc)."}}}},"required":["consentRecord","signature"],"type":"object"}}}}}
>
  
</RequestSchema>

<StatusCodes
  id={undefined}
  label={undefined}
  responses={{"200":{"content":{"application/json":{"schema":{"properties":{"consentRecord":{"type":"object","title":"ConsentRecord","description":"A consent record expresses consent (as defined in this building block's specification) to a single DataAgreement. There must be a UNIQUE constraint on (data agreement revision, individual)","x-not-in-database":false,"required":["id","agreementRevisionHash","state"],"properties":{"id":{"type":"string","format":"","example":"","description":"Objects may be passed back by some API endpoints without an ID (PK), denoting that they are a \"draft\", i.e. a ConsentRecord that is not yet stored in the database and only exist in transit. Draft ConsentRecords do not have a Revision, but if paired up with a Signature, a valid Revision should be generated."},"dataAgreementId":{"type":"string","x-fk-model":"DataAgreement","description":"The DataAgreement to which consent has been given"},"dataAgreementRevisionId":{"type":"string","x-fk-model":"Revision","description":"The Revision of the data agreement which consent has been given to"},"dataAgreementRevisionHash":{"type":"string","format":"","example":"","description":"Copy of the revision hash. The hash is the included in the signature and ensures against tampering with the original agreement."},"individualId":{"type":"string","x-fk-model":"Individual","description":"The Individual who has signed this consent record"},"optIn":{"type":"boolean","format":"","example":"","description":"True: The individual has positively opted in. False: The individual has explicitly said no (or withdrawn a previous consent)."},"state":{"type":"string","format":"","example":"","description":"The state field is used to record state changes after-the-fact. It is maintained by the Consent BB itself. Valid states: unsigned/pending more signatures/signed","enum":["unsigned","signed"]},"signatureId":{"type":"string","x-fk-model":"Signature","description":"A signature that hashes all the values of the consent record and has signed it with the key of the Invidiual, making it verifiable and tamper-proof. TBD: Relation to a Signature schema?"},"sectorPreferences":{"type":"array","items":{"type":"object","description":"specifies the preferred sector details","x-not-in-database":false,"required":["sector","location"],"properties":{"sector":{"type":"string","format":"","example":"","description":"Name of the sector"},"optIn":{"type":"boolean","description":"Defines sector is opted in or not"},"isLastUpdated":{"type":"boolean","description":"Defines consent record for this sector is last updated"}}}}}},"revision":{"type":"object","title":"Revision","description":"A *generic* revision model captures the serialised contents of any schema's single row. This is then subject to 1) cryptographic signature and 2) auditing.\n\nAside from the \"successor\" column, a revision should be considered locked.","x-not-in-database":false,"required":["id","schemaName","objectId","objectData","serizalizedSnapshot","serializedHash","timestamp"],"properties":{"id":{"type":"string","format":"","example":"","description":"Revision ID"},"schemaName":{"type":"string","format":"","example":"","description":"Previously \"schema\" but for technical reasons should be called \"schemaName\"","enum":["dataAgreement","policy","dataAgreementRecord"]},"objectId":{"type":"string","format":"","example":"","description":"The PK of the object that was serialised"},"objectData":{"type":"string","format":"","example":"","description":"The object that is serialised"},"signedWithoutObjectId":{"type":"boolean","format":"","example":"","description":"Indicates that objectId was left blank in serizalizedSnapshot when calculating serializedHash. objectId may subsequently be filled in."},"serizalizedSnapshot":{"type":"string","format":"","example":"","description":"Revisioned data (sed as JSON) as a dict. Apply JSON Canonicalization Scheme as per IETF RFC 8785.  It contains all the fields of the schema except sucessorId, serializedHash, serializedSnapshot.\n"},"serializedHash":{"type":"string","format":"","example":"","description":"Hash of serizalizedSnapshot (SHA-1)"},"timestamp":{"type":"string","format":"","example":"","description":"Timestamp of when revisioning happened. It should be ISO 8601 UTC date time"},"authorizedByIndividualId":{"description":"Individual ID","type":"string"},"authorizedByOtherId":{"type":"string","format":"","example":"","description":"Reference to an admin user that has created this revision"},"successorId":{"x-fk-model":"Revision","type":"string","description":"If this revision is no longer the latest revision, refer to its successor"},"predecessorHash":{"type":"string","format":"","example":"","description":"Tamper-resistent artifact from previous record, copied from serializedHash"},"predecessorSignature":{"type":"string","format":"","example":"","description":"Tamper-resistent artifact from previous record (we don't know if the previous record was signed or not)"}}},"signature":{"type":"object","title":"Signature","description":"A generic signature contains a cryptographic hash of some value,  together with a signature created by some private key in another system.  Required signing methods: Revision object or another Signature object.\n","x-not-in-database":false,"required":["payload","signature","verificationMethod","verificationPayload","verificationPayloadHash","verificationSignedBy","timestamp"],"properties":{"id":{"type":"string","format":"","example":"","description":"Objects may be passed back by some API endpoints without an id (PK), denoting that they are a \"draft\", i.e. a Signature that is not yet stored in the database and only exists in transit."},"payload":{"type":"string","format":"","example":"","description":"The final payload that is signed, constructed as a JSON serialisation of fields {verificationPayload: ..., verificationPayloadHash: ..., verificationMethod: ..., verificationArtifact: ..., verificationSignedBy: ..., verificationJwsHeader, timestamp: ..., signedWithoutObjectReference: ..., objectType: ..., objectReference: ...}. Serialised as a JSON dict. If the signature is generated before anything is stored in the database (and has a PK), then the objectReference should be omitted from the payload but filled in afterwards."},"signature":{"type":"string","format":"","example":"","description":"Signature of payload hash, the format of the signature should be specified by either verificationMethod or verificationJwsHeader"},"verificationMethod":{"type":"string","format":"","example":"","description":"A well-known string denoting which method is used. Valid values: TBD. This might be expanded with supported verification methods. There may be a minimal set of supported methods necessary."},"verificationPayload":{"type":"string","format":"","example":"","description":"Internally generated serialised version of the data referenced by objectType and objectReference - by extracting and serialising their data as JSON"},"verificationPayloadHash":{"type":"string","format":"","example":"","description":"Internally generated cryptographic hash of the value to be signed, i.e. the value of verificationPayload"},"verificationArtifact":{"type":"string","format":"","example":"","description":"A verification artifact in the form of a scanned object, image, signature etc"},"verificationSignedBy":{"type":"string","format":"","example":"","description":"Because an identifier's information may change over time, there is a need to store that information at the time of signing. In the case of a cryptographic signature, this field should contain some identifier for looking up or verifying the public key of the signing party. In the case of a non-cryptographic signature, this field could contain a natural individual's names, personal number, email addresses - store a snapshot that binds to the signature at the time of signing. In the case of a cryptographic signature, this may be the fingerprint of the individual's public key or in some cases, a token from the user's ID session."},"verificationSignedAs":{"type":"string","format":"","example":"","description":"DRAFT FIELD: Specifies the relationship between the authorising signature and the invidual which the payload concerns. This is relevant for Consent Records. Possible values: \"individual\" / \"delegate\"."},"verificationJwsHeader":{"type":"string","format":"","example":"","description":"Alternative to the verificationMethod, verificationHash and verificationSignature, give a JWS serialised object (RFC7515)"},"timestamp":{"type":"string","format":"","example":"","description":"Timestamp of signature, currently this field isn't part of the payload so it's not tamper-proof"},"signedWithoutObjectReference":{"type":"boolean","format":"","example":"","description":"Indicates that objectReference was left blank in the serialised version that was signed"},"objectType":{"type":"string","format":"","example":"","description":"Name of the schema model that objectReference points to. Values: \"signature\" or \"revision\"","enum":["revision","signature"]},"objectReference":{"type":"string","format":"","example":"","description":"A symmetric relation / back reference to the objectType that was signed. We are currently just modelling signing another signature (a chain) or signing a Revision (which can be a revision of a consent record, an agreement, policy etc)."}}}},"type":"object"}}},"description":"","headers":{}},"400":{"description":"bad input parameter","headers":{}}}}
>
  
</StatusCodes>


      